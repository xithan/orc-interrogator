@inject HttpClient Http;
@inject IJSRuntime JsRuntime;
@using Interrogator.Game
@using Round = Interrogator.Game.Round
@using System.Runtime.Serialization
@using Interrogator.Game.Analysis
@using System.Runtime.CompilerServices
@using Interrogator.Game.Setup
@using Newtonsoft.Json
@using Duel = Interrogator.Game.Duel

<VegaChart SpecFile="betrayer.vg.json" Title="Worst Traitor" Height="@Height" Data="@Data" />

@code {

    private string Data
    {
        get
        {
            var data = JsonConvert.SerializeObject(this.CollectData());
            Console.WriteLine(data);
            return data;
        }
    }

    private int Height => 500;

    [Inject] 
    private PrisonManager PrisonManager { get; set; }
    
    [Parameter]
    public int RoundId { get; set; }

    private void AddDataPoints(Duel duel, Dictionary<(Prisoner,Move), int> dic)
    {
        var p2 = duel.Participants.Item2;
        var p1 = duel.Participants.Item1;
        var name1 = p1.Prisoner.Name;
        var name2 = p2.Prisoner.Name;
        this.UpdateEntry(p1.Prisoner, Move.Betray, p1.Moves, dic);
        this.UpdateEntry(p1.Prisoner, Move.Cooperate, p1.Moves, dic);
        this.UpdateEntry(p2.Prisoner, Move.Betray, p2.Moves, dic);
        this.UpdateEntry(p2.Prisoner, Move.Cooperate, p2.Moves, dic);
    }

    private void UpdateEntry(Prisoner p, Move move, List<Move> moves,  Dictionary<(Prisoner,Move), int> dic)
    {
        var key = (p, move);
        var count = moves.Count(m => m == move);
        if (dic.TryGetValue(key, out var oldCount ))
        {
            dic[key] = oldCount + count;
        }
        else
        {
            dic[key] = count;
        }
    }

    private IEnumerable<BetrayerDataPoint> CollectData()
    {
        var dic = new Dictionary<(Prisoner,Move), int>();
        foreach (var duel in PrisonManager.GetAllDuels())
        {
            this.AddDataPoints(duel, dic);
        }
        return dic.Select(pair => new BetrayerDataPoint(pair.Key.Item1.Name, pair.Key.Item2, pair.Value)).ToList()
        .OrderBy(x => x.MoveType).ThenByDescending<BetrayerDataPoint, int>(y => y.Count);
    }

}